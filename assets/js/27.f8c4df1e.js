(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{384:function(e,t,v){"use strict";v.r(t);var a=v(42),_=Object(a.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"vue-实现要点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-实现要点"}},[e._v("#")]),e._v(" vue 实现要点")]),e._v(" "),v("h2",{attrs:{id:"响应式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#响应式"}},[e._v("#")]),e._v(" 响应式")]),e._v(" "),v("p",[e._v("vue2 用观察者模式（订阅发布）实现了双向数据绑定。")]),e._v(" "),v("ol",[v("li",[e._v("在数据的 getter 属性中进行依赖注册，在 setter 中通知到 watcher")]),e._v(" "),v("li",[e._v("array 处理\n"),v("ol",[v("li",[e._v("重写了 array 的 push、pop 等方法，使得在使用 array 的时候也能够触发双向数据绑定的机制")])])]),e._v(" "),v("li",[e._v("代理到 this\n"),v("ol",[v("li",[e._v("将 data、prop、computed 数据代理到 this 上")])])])]),e._v(" "),v("h2",{attrs:{id:"事件机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事件机制"}},[e._v("#")]),e._v(" 事件机制")]),e._v(" "),v("ol",[v("li",[e._v("维护一个 watcher 队列，这个队列当任务不会立即执行。同一个 id 的任务（针对同一个 dom）的操作在队列中只会保留最新的状态。")]),e._v(" "),v("li",[e._v("使用浏览器的 task - micro task - render 策略来实现渲染，将 vue 的任务用 promise / MutationObserver 推送到 micro task 队列中（backup 方案：用 setTimeout 推送到 下一个循环的 task 队列，这样会稍微慢一点，UI 会多渲染一次）。")]),e._v(" "),v("li",[e._v("浏览器 task - micro task - render 策略\n"),v("ol",[v("li",[e._v("task\n"),v("ol",[v("li",[e._v("script(整体代码)")]),e._v(" "),v("li",[e._v("setTimeout")]),e._v(" "),v("li",[e._v("setInterval")]),e._v(" "),v("li",[e._v("I/O")]),e._v(" "),v("li",[e._v("UI 交互事件")]),e._v(" "),v("li",[e._v("postMessage")]),e._v(" "),v("li",[e._v("MessageChannel")]),e._v(" "),v("li",[e._v("setImmediate(Node.js 环境)")])])]),e._v(" "),v("li",[e._v("micro task\n"),v("ol",[v("li",[e._v("Promise.then")]),e._v(" "),v("li",[e._v("Object.observe")]),e._v(" "),v("li",[e._v("MutationObserver")]),e._v(" "),v("li",[e._v("process.nextTick(Node.js 环境)")])])]),e._v(" "),v("li",[e._v("执行顺序：task -> microTask -> render")])])])]),e._v(" "),v("h2",{attrs:{id:"dom-更新策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dom-更新策略"}},[e._v("#")]),e._v(" dom 更新策略")]),e._v(" "),v("p",[e._v("diff 算法目标：寻找需要修改的最小单位")]),e._v(" "),v("ol",[v("li",[e._v("同层的树节点进行比较而非对树进行逐层搜索遍历的方式，时间复杂度只有 O(n)")]),e._v(" "),v("li",[e._v("isSameNode ? patch : removeNode / createNode\n"),v("ol",[v("li",[e._v("sameNode: tag、key、isComment 都相同")])])]),e._v(" "),v("li",[e._v("patch: 针对单个节点")]),e._v(" "),v("li",[e._v("updateChildren：针对同一层级\n"),v("ol",[v("li",[e._v("new / old 从两头开始向中间遍历比对。")]),e._v(" "),v("li",[e._v("尽可能的就地复用")]),e._v(" "),v("li",[e._v("如果 new > old，则创建，则创建新的 vNode")]),e._v(" "),v("li",[e._v("如果 new < old，则将多余的 vNode 移除")])])]),e._v(" "),v("li",[e._v("Dom 操作\n"),v("ol",[v("li",[e._v("在 create / update 钩子中更新 Dom 属性")])])])]),e._v(" "),v("h2",{attrs:{id:"template-编译"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#template-编译"}},[e._v("#")]),e._v(" template 编译")]),e._v(" "),v("ol",[v("li",[e._v("以 render 函数为起点（如果不存在，则将其他写法，如 jsx，template 转为 render 函数）")]),e._v(" "),v("li",[e._v("template 被编译为 AST 抽象语法树 、 render 函数、staticRenderFns 字符串。")]),e._v(" "),v("li",[e._v("在编译中会使用函数缓存")]),e._v(" "),v("li",[e._v("最终 render 函数会生成 vNode")])]),e._v(" "),v("h2",{attrs:{id:"keep-alive-实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive-实现"}},[e._v("#")]),e._v(" keep-alive 实现")]),e._v(" "),v("p",[e._v("在 destroyed 中将满足条件的 vNode 缓存起来，在 create 中将 vNode 覆盖上去。")])])}),[],!1,null,null,null);t.default=_.exports}}]);